/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/oop.ts"
/*!***********************!*\
  !*** ./src/js/oop.ts ***!
  \***********************/
() {

eval("{var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n//Классы (User), методы (showInfo) (метод - функция, которую можно добавить внутрь класса), конструкторы (это метод. у нас написан через constructor). Поля для чтения (задаются в классе, которые используются только для чтения и изменить их нельзя. Вроде констант получаются. Пишется свойство \"readonly\" для обозначения поля для чтения. Нам нужно не всегда задавать все параметры. Делается это опционально. Для этого нужно поставить знак вопроса. (age&?: number). Параметр age является опциональным, и нам можно устанавливать его значение только тогда, когда нам  это нужно. А также можно использовать значение по умолчанию. В нашем примере вместо (age?: number) нужно написать age: number=34. И в таком случае будет браться только значение по умолчанию (34)). /Наследование/ В нашем примере class Employee extends User. Если есть конструктор в базовом (родительском) классе мы должны передать и в дочерний (все парамерты нужно передавать, не только конструктор). Параметры внутри конструктора передаются через super. Можно наследоваться только от одного класса. /Переопределение методов/(помечено внутри кода). /Абстрактные классы/ Они как шаблоны для классов. В данном случае мы наследовались от User, в котором есть конкретные свойства, логика. Но часто бывает, что мы определяем абстрактный класс, от которого потом наследуемся. От обычного класса можно создать объект. От абстрактного напрямую объект создать не может. Нужно будет создать доп. объект и только от него создавать объект. Пример ниже \nvar User = /** @class */function () {\n  function User(name, gender, age) {\n    this.name = name;\n    this._age = age;\n    this.gender = gender;\n  }\n  User.prototype.showInfo = function () {\n    console.log(\"My name is \".concat(this.name, \". I'm \").concat(this._age, \" year old\"));\n  };\n  User.prototype.toString = function () {\n    return \"\".concat(this.name, \": \").concat(this._age);\n  };\n  Object.defineProperty(User.prototype, \"age\", {\n    get: function () {\n      return this._age;\n    },\n    set: function (n) {\n      this._age = n;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return User;\n}();\nvar Employee = /** @class */function (_super) {\n  __extends(Employee, _super);\n  function Employee(name, gender, age) {\n    return _super.call(this, name, gender, age) || this;\n  }\n  Employee.prototype.toString = function () {\n    console.log(_super.prototype.toString.call(this)); //вызываем метод базового класса внутри. И в этом месте будет вызываться 2 параметра как в родительском классе.\n    return \"\".concat(this.name, \": \").concat(this.age, \": \").concat(this.company); //вернет переопределенный метод.\n  };\n  Employee.calculateYears = function (age) {\n    return Employee.retirementAge - age;\n  };\n  Employee.retirementAge = 65;\n  return Employee;\n}(User);\nvar user = new User(\"Ivan Ivanov\", \"male\");\nvar worker = new Employee(\"Sergei Morozov\", \"male\", 45);\nworker.company = \"Amazon\";\n//let user: User = new User(\"Ivan Ivanov\", \"male\", 25);\n/* Так записывается, если не нужен конструктор. В конструкторе свойства присваиваются внутри (). Выше видим.\nuser.name = \"Ivan Ivanov\";\nuser.age = 25;*/\nuser.age = 25; //Если какой-то параметр делаем protected - здесь сработает методе age (cеттор)\nconsole.log(user.age);\nuser.showInfo();\nconsole.log(user.toString());\nconsole.log(worker.toString());\n//user.gender = \"female\" В таком случае пишется ошибка, что изменить свойство gender невозможно\n//Абстрактные классы. Описание их написано выше в начале. Наследоваться будем следующим образом. Абстрактный - задает шаблон для конкретных классов.\nvar Figure = /** @class */function () {\n  function Figure() {}\n  Figure.prototype.showName = function () {\n    console.log(this.name);\n  };\n  return Figure;\n}();\n//class Rectangle extends Figure(){} - в данном случае невозможно наследоваться от Figure, поэтом нужно наследование писать следующим образом:\nvar Rectangle = /** @class */function (_super) {\n  __extends(Rectangle, _super);\n  function Rectangle(width, heigh) {\n    var _this = _super.call(this) || this;\n    _this.width = width;\n    _this.height = heigh;\n    return _this;\n  }\n  Rectangle.prototype.getArea = function () {\n    return this.width * this.height;\n  };\n  return Rectangle;\n}(Figure);\nvar rect = new Rectangle(100, 30);\nconsole.log(\"Rectangle area = \".concat(rect.getArea()));\nconsole.log(Employee.calculateYears(42));\nvar employee = {\n  id: 1,\n  name: \"Tom\"\n};\nvar Sedan = /** @class */function () {\n  function Sedan(id, name, weight) {\n    this.id = id;\n    this.name = name;\n    this.weight = weight;\n  }\n  Sedan.prototype.showInfo = function () {\n    console.log(\"\".concat(this.name));\n  };\n  return Sedan;\n}();\nvar Vehicle = /** @class */function () {\n  function Vehicle(id, name, weight) {\n    this.id = id;\n    this.name = name;\n    this.weight = weight;\n  }\n  Vehicle.prototype.showInfo = function () {\n    console.log(\"\".concat(this.name));\n  };\n  return Vehicle;\n}();\nvar car1 = new Sedan(1, \"Ford\", 1340);\nvar car2 = new Vehicle(2, \"Mersedes\", 15000);\nfunction showCarInfo(car) {\n  car.showInfo();\n}\nshowCarInfo(car1);\nshowCarInfo(car2);\nvar simpleBuilder = function (name, surname) {\n  return \"\".concat(name, \" \").concat(surname);\n};\nconsole.log(simpleBuilder(\"Edgar\", \"Zhiznevskij\"));\nvar addresses = [\"Адрес 1\", \"Адрес 2\"];\nvar colors = {};\ncolors[\"red\"] = \"#ff0000\";\ncolors[\"green\"] = \"#00ff00\";\ncolors[\"blue\"] = \"#0000ff\";\nconsole.log(colors[\"red\"]);\n/* В JS будет выглядеть так:\nlet colors = {\n    red : \"#ff0000\",\n    green : \"#00ff00\",\n    blue : \"#0000ff\"\n};\ncolors[\"red\"]\n*/\n//Преобразования типов. Employee наследуется от User, поэтому можем так написать.\nvar tom = new Employee(\"Tom Soyer\", \"male\");\n//Но если запишем так, то tom у нас больше User. Чтобы работало - нужно сделать преобразование типа в Enployee следующим образом:\nvar employeeTom = tom;\nemployeeTom.company = \"Amazon\";\n//C помощью преобразования типа мы добавили к tom параметр company (т.е. \"Amazon\")\n//Обобщения.Generick (Дженерик).\n\n//# sourceURL=webpack://test-typescript/./src/js/oop.ts?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/oop.ts"].call(__webpack_exports__);
/******/ 	
/******/ })()
;