/*Бесконечный цикл:
while(1){
    console.log('infinity rules!')
}*/
/* Когда ставится точка с запятой:
let a = 123;

a = Math.sort(4);

function summ(param1, param2) {
    return param1 + param2;
}

class Rect {

}*/
/* Переменные.
let num = 3;

console.log(num);

num = 56;

console.log(num);*/
/*Виды переменных 
Строки:
let str = "Hello"; //'Hello'
let str_inter = `${str * '123'}, world`; // получится ошибка No a number
let str_inter = `${12/0}, world`; // получится бесконечность
let str_inter = `${12/-0}, world`; // получится минус бесконечность
console.log(str_inter);*/

//Типы переменных:
let num_three = 3; // просто переменная
let str = "Hello"; // строка
let is_user = true; //- булевое значение
let empty = null; // - пустое значение. В отличие от null - undefaind - пустота.

//Объект. Комплексный тип (объявили 4 ключа и присвоили значения. Ключами могут быть только строковые значения. Пробел допускается внутри ковычек. Пары ключ-значения разделяются запятой:
/*let user = {
    name: "Developer",
    age: 25,
    is_married: false,
    salary: null,
    "has childs": true
}

console.log(user[0]);*/ // высвечивается undefaind

//Специальный вид объекта - массив (через запятую значения разных типов. Это список значений. Внутри массива могут быть не только числа, но строки и другие данные. Индексация начинается с 0. Внутри объектов такого нет.):
let arr = [1,2,3,4,5];
let arr1 = [1, "2", {num: '3'}];
// Можно сосдавать переменные с помощью слова const (константные переменные, неизменные)
const pi = 3.14;
 // pi = 34.23;будет ошибка высвечиваться
// Внутрь объекта можно добавлять свойства.
 const obj = {
    title: "Title"
}

obj.name = '1231';
// obj = 4; - будет ошибка. Потому что у нас есть константа. А переменную внутри объекта можно менять при const

// Условные операторы. Если условие верно мы выполняем одно, иначе другое. Что внутри if возвращает булевое значение true/false. Секция else - не обязательная. Может не присутствовать. Нужно чтобы было то, что высвечивается когда все верно. Если не писать else.
//num_three = 3;
/*if(num_three > 0) {
    console.log ('Положительное');
}
else {
    console.log ('Отрицательное')
}*/
// Можно написать сокращенно, с помощью тернарного апператора
/*if(num_three > 0) {
    console.log ('Положительное');
}
else {
    console.log ('Отрицательное')
}*/
// Сокращенная запись того, что выше. После вопроса, если положительное высвечивается первое, если отрицательное второе, после :
/*(num_three > 0) ? console.log ('Положительное'): console.lof ('Отрицательное');*/

//Свич (выбор из некоторого количества вариантов):
/*let color = 'blue';
//В свич передаем значение, которое мы передаем. Внутри свич - какие варианты возможны. Между case и break можно написать любое количество кода. Если значение color не совпало ни с одним из вариантов, можно определить инструкцию default. Значение в default высвечивается, если ничто выше не совпало с необходимым значением.
switch(color){
    case 'blue':
        console.log('Синий');
    break;

    case 'black':
        console.log('Черный');
    break

    case 'red':
        console.log('Красный');
    break

    default:
        console.log('Неопределенный')
}*/
//Напишем все, что в свич теперь через if
/*let color = red

if(color == 'blue') {
    console.log ('blue') 
}
if(color == 'black') {
    console.log ('black') 
}
if(color == 'red') {
    console.log ('red') 
}*/
//Напишем через if, else
/*if(color == 'blue') {
    console.log ('Синий') 
} else {
    if(color == 'black') {
        console.log ('Чeрный')
    } else{
        if(color == 'red') {
            console.log ('Красный')            
    } else{
        console.log ('Неопределенный')            
        }
    }
}*/

// Вывести переменную в консоль 10 раз
/*let hello = "Hello!!!";

console.log(hello);
console.log(hello);
console.log(hello);*/ // И так 10 раз, а если нужно 1000
// Здесь нам на помощь приходит цикл. Для циклов есть 3 ключевых слова (while, for, ). While (пишется условие при котором код повторится) - То есть пока правда в примере ниже. Пока правда все будет выполняться. Но так получится бесконечный цикл. Прервать можно с помощью
/*while(true){
    console.log('123');
}*/
//Чтобы вывести 10 раз нужно написать,чтобы правдой было 10 раз, а на 11 стало ложью. Нужно сделать, чтобы counter увеличивался. И в какой-то момент counter станет 11, вернется false и выполнение цикла завершится
/*let counter = 0;

while(counter < 10) {
    console.log(hello);
    counter +=1;
}*/

//Цикл for. Он более конкретный. Задаем начальное значение счетчика, кончное и шаг. Выполним ту же задачу. Вывести 10 раз. Внутри for мы задаем начальное значение. for(задаем переменную и начальную точку, задаем условие, задаем шаг)
/*for(let i = 0; i < 10; i+=1) { //или i++
    console.log(hello);
}*/

//Функции.
// Программа должна уметь складывать числа. Вывести в консоль сумму чисел. Можно сделать.
console.log(22+45);
//Все это можно сделать с помощью функции. Функции принимают на вход параметры, обрабатывае их и выдает результат. Нужно сочинить функции.С помощью слова function задаем и даем имя, дальше обязательно нужны скобочки, чтобы показать, что это функция. дальше пишем логику. Функции можно задавать разное каличество параментов (param1 и т.д.)

function summ(param1,param2) {
    console.log(param1+param2);
}

summ();
summ(2,2);
summ(2,4);

//Функция, которая возвращает результат. Для этого используем слово return. Мы можем не пользоваться результатом вывода. Функции м/б любой степени сложности с любым количеством аргументов.
function summ(param1,param2) {
    let result = param1+param2; 
    console.log(result);
    
    return result;
}

summ(2,2);

let total = summ(2,4);

console.log(total ** 2);

// Напишем закон всемирного тяготения (F=G*m1m2/r2 ). Константа используется внутри функции, поэтому внутри ее и определяем:

function gravity(m1, m2, r){
    const G = 6.6743e-11;
    let result = G * ((m1 * m2)/(r ** 2));

    return result;
}

//вызываем функцию:
let g = gravity(80, 90, 1);
//выводим в консоль
console.log(g);

//Вернемся к объектам. Коллекция пар ключ-значение. Может быть. Функция может быть значением ключа (мы определили ключ, а его значением является функция, которая выводит определенный результат). Посмотрим как ее из объекта вызвать.
let user = {
    name: "Developer programmer",
    age: 25,
    is_married: false,
    salary: null,
    "has childs": true,
    say_hi: function() {
        /*console.log(`Hello, my name is ${user.name}`); // получаем доступ через указание имени объекта и его ключа name*/
        // Доступ к свойствам объекта осуществляется через this.
        console.log(`Hello, my name is ${this.name}`);
    },
    //напишем более сокращенно say_age:
    say_age(){
        console.log(`I am ${this.age} years old`);
    }
}
//Вызовем сейчас функцию из объекта:
user.say_hi();
//Можно вызвать еще так. () - указывает, что это функция:
user["say_hi"]();

user.say_age();

// Значение присвоилось по значению.С примитивными типами это хорошо работает. С объектами немножко по-другому.
let perem = 345;
let terem = perem;
//Копирование значений рассмотрим:
console.log(perem);
console.log(terem);

terem = 567;

console.log(perem);
console.log(terem);
//Как с объектами будет. Получается изменение свойств одного объекта автоматически изменяет свойство другого. Это называется - Копирование по ссылке. Здесь мы присвоили не по значению, а по ссылке/ То же самое и с массивами:
let elem = {
    name: "Block"
}

//let new_elem = elem; - значение будет меняться на новое.
//А вот в таком случае переменная new не будет менять значение 
let new_elem = {      
    name: elem.name
}

console.log(elem);
console.log(new_elem);

new_elem.name = "Paragraph"

console.log(elem);
console.log(new_elem);
// Как выходить из такого положения. Вручную скопировать свойство одного в другое.

//Классы.
// Нужно создать множество объектов с различными свойствами.
//Классически будет так: 
/*let mersedes = {
    name: "Mersedes",
    year: 1995,
}

let mazda = {
    name: "Mazda",
    year: 1995,
}*/
//Для этого служит специальная фукнция. Функции-конструкторы. (принимает свойства, и создает в результате объект). Ее название обычно начинается с большой буквы. Так договорились, что они должны начинаться с большой буквы. Она конструирует объект и возвращает результат. this.name - определяет свойства объекта. И эту функцию нужно вызывать определенным образом.
function Car(name, year, factory) {
    this.name = name;
    this.year = year;
    this.factory = factory;
}
//Вызываем функцию-конструктор. Вызывается с помощью слова new. В результате объекту присвоятся свойства: 
let mersedes = new Car("Mersedes", 1995, {name: "Super Zavod", address: "Germany"});
let mazda = new Car("Mazda", 1999, {name: "Anorher zavod", address: "Japan"});

console.log(mersedes);
console.log(mazda.factory.name);
//Классический способ.:
/*function car(name, year) {
    let obj = {};

    obj.name = name;
    obj.year = year;

    return obj;
}
let mersedes1 = car("Mersedes", 1995);

console.log(mersedes1);*/

//Значением могут быть другие объекты. Внесем factory - это будет объект (фабрика). Будет описывать завод, на котором выпущен автомобиль. Выше все сделано

//Вызов методов на примитивах.
let str1 = "Hello";
let num_trhee = 3;
console.log(str.length);
console.log(str.toUpperCase);
console.log('Это число ' + num_three.toLocaleString());

let n = new Number(3.445742158);
console.log(n.toFixed(2));